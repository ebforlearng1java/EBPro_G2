package co.jp.chapterOOP;

public class JavaHomeWorkOOP {

	public static void main(String[] args) {
		//質問１︓クラス（Class）とは︖クラス定義⽤のキーワードは「 class 」である。
		//答：类是模板、模型，描述一类对象共同的行为和方法。类名首字母大些和文件同名。
		/* package 所属的包名; 
		   		修飾子 class クラス名 {
			}
		*/
		
		
		//質問２︓クラスメンバ（Class member）の何種類ありますか。
		//答：有2种。属性和对属性的操作（方法、函数）
		//1. 属性・フィールド (Field)
		//2. 関数(Function)・メソッド(Method)・操作(Operator)
		
		
		//質問３︓クラスメンバの関数は特殊の関数「コンストラクタ」が持っています。
		//答：构造函数，在类生成实例时，new之后调用，是特殊的方法。作用是初始化对象。
		//       我们还可以自定义构造函数，这时默认的构造函数自动失效。
		
		
		//質問４︓コンストラクタの特徴
		/* 答：1. 没有返回值戻り値不要。（void）也不用加。
		       2. 函数名等于类名
		*/
		
		
		//質問５︓コンストラクタの作⽤︓クラス属性の初期化する。
		//答：默认的构造函数，生成对象时，初始化对象的属性值
		
		
		//質問６︓１つクラスに複数のコンストラクタ持つ可能。
		//答：对，一个类可以有多个构造函数。多个构造函数就是重载
		
		
		//質問７︓キーワード this の使⽤⽅法︓ this.name ︖ name ?
		//答：使用方法是this.name = name;
		
		
		//質問８︓クラスを利⽤する為、インスタンス化する必要です。インスタンスの演算⼦はnew です。
		//答：类名 变量名 = new 类名();八大基本类型可以省略new
		
		
		//質問９︓演算⼦ new の直後呼び出しているメソッドは「コンストラクタ」︔
		//答：类生成实例对象，new之后自动调用构造函数。
		
		
		//質問１０︓アクセス制御の３種類あります。
		//答：公有public：谁都可以访问，同一个包类、不同包的类、子类都可以访问到
		//    私有private：只有自己可以访问，其他都不可以访问到
		//    保护protected：同包的类和子类可以访问到，不同包的不可以
		
		
		//質問１１︓静的のメンバの定義するキーワード（修飾⼦）は static 。
		//答：不实例也可以访问到。类名.属性  类名.方法名(参数)
		//     类的静态成员是全部实例对象共有的
		
		
		//質問１２︓静的のメンバアクセス時、インスタンス化不要。アクセス⽅法は「クラス名.静的のメンバ」。
		//答：静态属性和方法不需要实例化也可以访问。类名.静态属性，类名.静态方法名
		
		
		//質問１３︓クラス「Animal」を定義して、インスタンス化しオブジェクト cat を作成します。
		//          変数catのsayHello()メソッドを呼び出してください。
		/*1. 属性︓年齢
		  2. 属性︓名前
		  3. 属性︓分類
		  4. コンストラクタ︓名前を渡して、初期化する
		  5. 操作︓sayHello()︓void
  		  6. 操作︓getName(): String ⾃分の名称を返す
  		*/
		Animal cat = new Animal("cat");
		cat.sayHello();
		
		
		//質問１４︓以下１⾏を解釈してください。
		System.out.println(new Animal("cat").getName());
		//答：Animal类实例化调用了getName方法，并且把它输出。这里省略了实例化变量名
		
		
		//質問１５︓クラス継承する⽤キーワードは「 extends 」︖
		//答：是的。修饰子 class 类名 extends 父类名
		
		
		//質問１６︓継承しているクラス。上位クラスは「親クラス」・「スーパークラス」。下位クラスは「サブクラス」と呼びます。
		//答：派生的（衍生）类称为“子类”。 被继承的人被称为“超类”或“父类”。
		
		
		//質問１７︓サブクラス＆アクセス制御（ public, protected ）。
		//答：子类只能继承父类中 public和 protected的属性和方法
		
		
		//質問１８︓サブクラスと親クラス同じメソッド名かつメソッドの引数は⼀致する場合、「オーバーライド」となります。
		//答：override重写。子类对父类的允许访问的方法的实现过程进行重新编写，方法名和参数都一样。在子类不想原封不动继承父类方法的时候使用
		
		
		/*質問１９︓以下Animalクラスを継承して以下２クラスを作成してください。
		 1. クラス Cat。sayHelloメソッドをオーバーライドして、System.out.println(“ニャー“);
		 2. クラス Dog。sayHelloメソッドをオーバーライドして、System.out.println(“ワン“);
		※親クラスに明⽰的なコンストラクタが存在しない場合、サブクラスは必ず親クラスのコンストラクタをオーバーライドします。
		*/
		
		
		//質問２０︓以下コードをIS-A関係で説明してください。
		/*
		  Animal v0 = new Animal(); // v0 は Animal 型
          Animal v1 = new Cat("a cat"); // v1 は Cat 型, v1 は Animal 型
          Animal v2 = new Dog("a dog"); // v2 は Dog 型, v2 は Animal 型
          Cat v3 = new Cat(""); // OK
          Dog v4 = new Dog(""); // OK
          Cat v5 = new Animal(""); // NG
        */
		/*
		 * 答：Animal v0 = new Animal();括号里缺少String类型参数
		 *     Animal v1 = new Cat("a cat"); v1是Animal类型
		 *     Animal v2 = new Dog("a dog"); v1是Animal类型
		 *     Cat v3 = new Cat(""); v3是Cat类型，Cat类是Animal类的一种
		 *     Dog v4 = new Dog(""); v4是Dog类型，Dog类是Animal类的一种
		 *     Cat v5 = new Animal(""); 错误语句，不能从Animal变成Cat，
		 */
		
	}

}
